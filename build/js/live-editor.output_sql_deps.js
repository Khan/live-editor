/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./external/html2canvas/html2canvas.js":
/*!*********************************************!*\
  !*** ./external/html2canvas/html2canvas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n html2canvas 0.4.1 <http://html2canvas.hertzen.com>\n Copyright (c) 2013 Niklas von Hertzen\n\n Released under MIT License\n */\n\n(function(window, document, undefined){\n\n    \"use strict\";\n\n    var _html2canvas = {},\n        previousElement,\n        computedCSS,\n        html2canvas;\n\n    _html2canvas.Util = {};\n\n    _html2canvas.Util.log = function(a) {\n        if (_html2canvas.logging && window.console && window.console.log) {\n            window.console.log(a);\n        }\n    };\n\n    _html2canvas.Util.trimText = (function(isNative){\n        return function(input) {\n            return isNative ? isNative.apply(input) : ((input || '') + '').replace( /^\\s+|\\s+$/g , '' );\n        };\n    })(String.prototype.trim);\n\n    _html2canvas.Util.asFloat = function(v) {\n        return parseFloat(v);\n    };\n\n    (function() {\n        // TODO: support all possible length values\n        var TEXT_SHADOW_PROPERTY = /((rgba|rgb)\\([^\\)]+\\)(\\s-?\\d+px){0,})/g;\n        var TEXT_SHADOW_VALUES = /(-?\\d+px)|(#.+)|(rgb\\(.+\\))|(rgba\\(.+\\))/g;\n        _html2canvas.Util.parseTextShadows = function (value) {\n            if (!value || value === 'none') {\n                return [];\n            }\n\n            // find multiple shadow declarations\n            var shadows = value.match(TEXT_SHADOW_PROPERTY),\n                results = [];\n            for (var i = 0; shadows && (i < shadows.length); i++) {\n                var s = shadows[i].match(TEXT_SHADOW_VALUES);\n                results.push({\n                    color: s[0],\n                    offsetX: s[1] ? s[1].replace('px', '') : 0,\n                    offsetY: s[2] ? s[2].replace('px', '') : 0,\n                    blur: s[3] ? s[3].replace('px', '') : 0\n                });\n            }\n            return results;\n        };\n    })();\n\n\n    _html2canvas.Util.parseBackgroundImage = function (value) {\n        var whitespace = ' \\r\\n\\t',\n            method, definition, prefix, prefix_i, block, results = [],\n            c, mode = 0, numParen = 0, quote, args;\n\n        var appendResult = function(){\n            if(method) {\n                if(definition.substr( 0, 1 ) === '\"') {\n                    definition = definition.substr( 1, definition.length - 2 );\n                }\n                if(definition) {\n                    args.push(definition);\n                }\n                if(method.substr( 0, 1 ) === '-' &&\n                    (prefix_i = method.indexOf( '-', 1 ) + 1) > 0) {\n                    prefix = method.substr( 0, prefix_i);\n                    method = method.substr( prefix_i );\n                }\n                results.push({\n                    prefix: prefix,\n                    method: method.toLowerCase(),\n                    value: block,\n                    args: args\n                });\n            }\n            args = []; //for some odd reason, setting .length = 0 didn't work in safari\n            method =\n                prefix =\n                    definition =\n                        block = '';\n        };\n\n        appendResult();\n        for(var i = 0, ii = value.length; i<ii; i++) {\n            c = value[i];\n            if(mode === 0 && whitespace.indexOf( c ) > -1){\n                continue;\n            }\n            switch(c) {\n                case '\"':\n                    if(!quote) {\n                        quote = c;\n                    }\n                    else if(quote === c) {\n                        quote = null;\n                    }\n                    break;\n\n                case '(':\n                    if(quote) { break; }\n                    else if(mode === 0) {\n                        mode = 1;\n                        block += c;\n                        continue;\n                    } else {\n                        numParen++;\n                    }\n                    break;\n\n                case ')':\n                    if(quote) { break; }\n                    else if(mode === 1) {\n                        if(numParen === 0) {\n                            mode = 0;\n                            block += c;\n                            appendResult();\n                            continue;\n                        } else {\n                            numParen--;\n                        }\n                    }\n                    break;\n\n                case ',':\n                    if(quote) { break; }\n                    else if(mode === 0) {\n                        appendResult();\n                        continue;\n                    }\n                    else if (mode === 1) {\n                        if(numParen === 0 && !method.match(/^url$/i)) {\n                            args.push(definition);\n                            definition = '';\n                            block += c;\n                            continue;\n                        }\n                    }\n                    break;\n            }\n\n            block += c;\n            if(mode === 0) { method += c; }\n            else { definition += c; }\n        }\n        appendResult();\n\n        return results;\n    };\n\n    _html2canvas.Util.Bounds = function (element) {\n        var clientRect, bounds = {};\n\n        if (element.getBoundingClientRect){\n            clientRect = element.getBoundingClientRect();\n\n            // TODO add scroll position to bounds, so no scrolling of window necessary\n            bounds.top = clientRect.top;\n            bounds.bottom = clientRect.bottom || (clientRect.top + clientRect.height);\n            bounds.left = clientRect.left;\n\n            bounds.width = element.offsetWidth;\n            bounds.height = element.offsetHeight;\n        }\n\n        return bounds;\n    };\n\n// TODO ideally, we'd want everything to go through this function instead of Util.Bounds,\n// but would require further work to calculate the correct positions for elements with offsetParents\n    _html2canvas.Util.OffsetBounds = function (element) {\n        var parent = element.offsetParent ? _html2canvas.Util.OffsetBounds(element.offsetParent) : {top: 0, left: 0};\n\n        return {\n            top: element.offsetTop + parent.top,\n            bottom: element.offsetTop + element.offsetHeight + parent.top,\n            left: element.offsetLeft + parent.left,\n            width: element.offsetWidth,\n            height: element.offsetHeight\n        };\n    };\n\n    function toPX(element, attribute, value ) {\n        var rsLeft = element.runtimeStyle && element.runtimeStyle[attribute],\n            left,\n            style = element.style;\n\n        // Check if we are not dealing with pixels, (Opera has issues with this)\n        // Ported from jQuery css.js\n        // From the awesome hack by Dean Edwards\n        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n        // If we're not dealing with a regular pixel number\n        // but a number that has a weird ending, we need to convert it to pixels\n\n        if ( !/^-?[0-9]+\\.?[0-9]*(?:px)?$/i.test( value ) && /^-?\\d/.test(value) ) {\n            // Remember the original values\n            left = style.left;\n\n            // Put in the new values to get a computed value out\n            if (rsLeft) {\n                element.runtimeStyle.left = element.currentStyle.left;\n            }\n            style.left = attribute === \"fontSize\" ? \"1em\" : (value || 0);\n            value = style.pixelLeft + \"px\";\n\n            // Revert the changed values\n            style.left = left;\n            if (rsLeft) {\n                element.runtimeStyle.left = rsLeft;\n            }\n        }\n\n        if (!/^(thin|medium|thick)$/i.test(value)) {\n            return Math.round(parseFloat(value)) + \"px\";\n        }\n\n        return value;\n    }\n\n    function asInt(val) {\n        return parseInt(val, 10);\n    }\n\n    function parseBackgroundSizePosition(value, element, attribute, index) {\n        value = (value || '').split(',');\n        value = value[index || 0] || value[0] || 'auto';\n        value = _html2canvas.Util.trimText(value).split(' ');\n\n        if(attribute === 'backgroundSize' && (!value[0] || value[0].match(/cover|contain|auto/))) {\n            //these values will be handled in the parent function\n        } else {\n            value[0] = (value[0].indexOf( \"%\" ) === -1) ? toPX(element, attribute + \"X\", value[0]) : value[0];\n            if(value[1] === undefined) {\n                if(attribute === 'backgroundSize') {\n                    value[1] = 'auto';\n                    return value;\n                } else {\n                    // IE 9 doesn't return double digit always\n                    value[1] = value[0];\n                }\n            }\n            value[1] = (value[1].indexOf(\"%\") === -1) ? toPX(element, attribute + \"Y\", value[1]) : value[1];\n        }\n        return value;\n    }\n\n    _html2canvas.Util.getCSS = function (element, attribute, index) {\n        if (previousElement !== element) {\n            computedCSS = document.defaultView.getComputedStyle(element, null);\n        }\n\n        var value = computedCSS[attribute];\n\n        if (/^background(Size|Position)$/.test(attribute)) {\n            return parseBackgroundSizePosition(value, element, attribute, index);\n        } else if (/border(Top|Bottom)(Left|Right)Radius/.test(attribute)) {\n            var arr = value.split(\" \");\n            if (arr.length <= 1) {\n                arr[1] = arr[0];\n            }\n            return arr.map(asInt);\n        }\n\n        return value;\n    };\n\n    _html2canvas.Util.resizeBounds = function( current_width, current_height, target_width, target_height, stretch_mode ){\n        var target_ratio = target_width / target_height,\n            current_ratio = current_width / current_height,\n            output_width, output_height;\n\n        if(!stretch_mode || stretch_mode === 'auto') {\n            output_width = target_width;\n            output_height = target_height;\n        } else if(target_ratio < current_ratio ^ stretch_mode === 'contain') {\n            output_height = target_height;\n            output_width = target_height * current_ratio;\n        } else {\n            output_width = target_width;\n            output_height = target_width / current_ratio;\n        }\n\n        return {\n            width: output_width,\n            height: output_height\n        };\n    };\n\n    function backgroundBoundsFactory( prop, el, bounds, image, imageIndex, backgroundSize ) {\n        var bgposition =  _html2canvas.Util.getCSS( el, prop, imageIndex ) ,\n            topPos,\n            left,\n            percentage,\n            val;\n\n        if (bgposition.length === 1){\n            val = bgposition[0];\n\n            bgposition = [];\n\n            bgposition[0] = val;\n            bgposition[1] = val;\n        }\n\n        if (bgposition[0].toString().indexOf(\"%\") !== -1){\n            percentage = (parseFloat(bgposition[0])/100);\n            left = bounds.width * percentage;\n            if(prop !== 'backgroundSize') {\n                left -= (backgroundSize || image).width*percentage;\n            }\n        } else {\n            if(prop === 'backgroundSize') {\n                if(bgposition[0] === 'auto') {\n                    left = image.width;\n                } else {\n                    if (/contain|cover/.test(bgposition[0])) {\n                        var resized = _html2canvas.Util.resizeBounds(image.width, image.height, bounds.width, bounds.height, bgposition[0]);\n                        left = resized.width;\n                        topPos = resized.height;\n                    } else {\n                        left = parseInt(bgposition[0], 10);\n                    }\n                }\n            } else {\n                left = parseInt( bgposition[0], 10);\n            }\n        }\n\n\n        if(bgposition[1] === 'auto') {\n            topPos = left / image.width * image.height;\n        } else if (bgposition[1].toString().indexOf(\"%\") !== -1){\n            percentage = (parseFloat(bgposition[1])/100);\n            topPos =  bounds.height * percentage;\n            if(prop !== 'backgroundSize') {\n                topPos -= (backgroundSize || image).height * percentage;\n            }\n\n        } else {\n            topPos = parseInt(bgposition[1],10);\n        }\n\n        return [left, topPos];\n    }\n\n    _html2canvas.Util.BackgroundPosition = function( el, bounds, image, imageIndex, backgroundSize ) {\n        var result = backgroundBoundsFactory( 'backgroundPosition', el, bounds, image, imageIndex, backgroundSize );\n        return { left: result[0], top: result[1] };\n    };\n\n    _html2canvas.Util.BackgroundSize = function( el, bounds, image, imageIndex ) {\n        var result = backgroundBoundsFactory( 'backgroundSize', el, bounds, image, imageIndex );\n        return { width: result[0], height: result[1] };\n    };\n\n    _html2canvas.Util.Extend = function (options, defaults) {\n        for (var key in options) {\n            if (options.hasOwnProperty(key)) {\n                defaults[key] = options[key];\n            }\n        }\n        return defaults;\n    };\n\n\n    /*\n     * Derived from jQuery.contents()\n     * Copyright 2010, John Resig\n     * Dual licensed under the MIT or GPL Version 2 licenses.\n     * http://jquery.org/license\n     */\n    _html2canvas.Util.Children = function( elem ) {\n        var children;\n        try {\n            children = (elem.nodeName && elem.nodeName.toUpperCase() === \"IFRAME\") ? elem.contentDocument || elem.contentWindow.document : (function(array) {\n                var ret = [];\n                if (array !== null) {\n                    (function(first, second ) {\n                        var i = first.length,\n                            j = 0;\n\n                        if (typeof second.length === \"number\") {\n                            for (var l = second.length; j < l; j++) {\n                                first[i++] = second[j];\n                            }\n                        } else {\n                            while (second[j] !== undefined) {\n                                first[i++] = second[j++];\n                            }\n                        }\n\n                        first.length = i;\n\n                        return first;\n                    })(ret, array);\n                }\n                return ret;\n            })(elem.childNodes);\n\n        } catch (ex) {\n            _html2canvas.Util.log(\"html2canvas.Util.Children failed with exception: \" + ex.message);\n            children = [];\n        }\n        return children;\n    };\n\n    _html2canvas.Util.isTransparent = function(backgroundColor) {\n        return (backgroundColor === \"transparent\" || backgroundColor === \"rgba(0, 0, 0, 0)\");\n    };\n    _html2canvas.Util.Font = (function () {\n\n        var fontData = {};\n\n        return function(font, fontSize, doc, options) {\n            if (fontData[font + \"-\" + fontSize] !== undefined) {\n                return fontData[font + \"-\" + fontSize];\n            }\n\n            var container = doc.createElement('div'),\n                img = doc.createElement('img'),\n                span = doc.createElement('span'),\n                sampleText = 'Hidden Text',\n                baseline,\n                middle,\n                metricsObj;\n\n            container.style.visibility = \"hidden\";\n            container.style.fontFamily = font;\n            container.style.fontSize = fontSize;\n            container.style.margin = 0;\n            container.style.padding = 0;\n\n            doc.body.appendChild(container);\n            img.src = options.imagesDir + \"spacer.gif\";\n            img.width = 1;\n            img.height = 1;\n\n            img.style.margin = 0;\n            img.style.padding = 0;\n            img.style.verticalAlign = \"baseline\";\n\n            span.style.fontFamily = font;\n            span.style.fontSize = fontSize;\n            span.style.margin = 0;\n            span.style.padding = 0;\n\n            span.appendChild(doc.createTextNode(sampleText));\n            container.appendChild(span);\n            container.appendChild(img);\n            baseline = (img.offsetTop - span.offsetTop) + 1;\n\n            container.removeChild(span);\n            container.appendChild(doc.createTextNode(sampleText));\n\n            container.style.lineHeight = \"normal\";\n            img.style.verticalAlign = \"super\";\n\n            middle = (img.offsetTop-container.offsetTop) + 1;\n            metricsObj = {\n                baseline: baseline,\n                lineWidth: 1,\n                middle: middle\n            };\n\n            fontData[font + \"-\" + fontSize] = metricsObj;\n\n            doc.body.removeChild(container);\n\n            return metricsObj;\n        };\n    })();\n\n    (function(){\n        var Util = _html2canvas.Util,\n            Generate = {};\n\n        _html2canvas.Generate = Generate;\n\n        var reGradients = [\n            /^(-webkit-linear-gradient)\\(([a-z\\s]+)([\\w\\d\\.\\s,%\\(\\)]+)\\)$/,\n            /^(-o-linear-gradient)\\(([a-z\\s]+)([\\w\\d\\.\\s,%\\(\\)]+)\\)$/,\n            /^(-webkit-gradient)\\((linear|radial),\\s((?:\\d{1,3}%?)\\s(?:\\d{1,3}%?),\\s(?:\\d{1,3}%?)\\s(?:\\d{1,3}%?))([\\w\\d\\.\\s,%\\(\\)\\-]+)\\)$/,\n            /^(-moz-linear-gradient)\\(((?:\\d{1,3}%?)\\s(?:\\d{1,3}%?))([\\w\\d\\.\\s,%\\(\\)]+)\\)$/,\n            /^(-webkit-radial-gradient)\\(((?:\\d{1,3}%?)\\s(?:\\d{1,3}%?)),\\s(\\w+)\\s([a-z\\-]+)([\\w\\d\\.\\s,%\\(\\)]+)\\)$/,\n            /^(-moz-radial-gradient)\\(((?:\\d{1,3}%?)\\s(?:\\d{1,3}%?)),\\s(\\w+)\\s?([a-z\\-]*)([\\w\\d\\.\\s,%\\(\\)]+)\\)$/,\n            /^(-o-radial-gradient)\\(((?:\\d{1,3}%?)\\s(?:\\d{1,3}%?)),\\s(\\w+)\\s([a-z\\-]+)([\\w\\d\\.\\s,%\\(\\)]+)\\)$/\n        ];\n\n        /*\n         * TODO: Add IE10 vendor prefix (-ms) support\n         * TODO: Add W3C gradient (linear-gradient) support\n         * TODO: Add old Webkit -webkit-gradient(radial, ...) support\n         * TODO: Maybe some RegExp optimizations are possible ;o)\n         */\n        Generate.parseGradient = function(css, bounds) {\n            var gradient, i, len = reGradients.length, m1, stop, m2, m2Len, step, m3, tl,tr,br,bl;\n\n            for(i = 0; i < len; i+=1){\n                m1 = css.match(reGradients[i]);\n                if(m1) {\n                    break;\n                }\n            }\n\n            if(m1) {\n                switch(m1[1]) {\n                    case '-webkit-linear-gradient':\n                    case '-o-linear-gradient':\n\n                        gradient = {\n                            type: 'linear',\n                            x0: null,\n                            y0: null,\n                            x1: null,\n                            y1: null,\n                            colorStops: []\n                        };\n\n                        // get coordinates\n                        m2 = m1[2].match(/\\w+/g);\n                        if(m2){\n                            m2Len = m2.length;\n                            for(i = 0; i < m2Len; i+=1){\n                                switch(m2[i]) {\n                                    case 'top':\n                                        gradient.y0 = 0;\n                                        gradient.y1 = bounds.height;\n                                        break;\n\n                                    case 'right':\n                                        gradient.x0 = bounds.width;\n                                        gradient.x1 = 0;\n                                        break;\n\n                                    case 'bottom':\n                                        gradient.y0 = bounds.height;\n                                        gradient.y1 = 0;\n                                        break;\n\n                                    case 'left':\n                                        gradient.x0 = 0;\n                                        gradient.x1 = bounds.width;\n                                        break;\n                                }\n                            }\n                        }\n                        if(gradient.x0 === null && gradient.x1 === null){ // center\n                            gradient.x0 = gradient.x1 = bounds.width / 2;\n                        }\n                        if(gradient.y0 === null && gradient.y1 === null){ // center\n                            gradient.y0 = gradient.y1 = bounds.height / 2;\n                        }\n\n                        // get colors and stops\n                        m2 = m1[3].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\)(?:\\s\\d{1,3}(?:%|px))?)+/g);\n                        if(m2){\n                            m2Len = m2.length;\n                            step = 1 / Math.max(m2Len - 1, 1);\n                            for(i = 0; i < m2Len; i+=1){\n                                m3 = m2[i].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\))\\s*(\\d{1,3})?(%|px)?/);\n                                if(m3[2]){\n                                    stop = parseFloat(m3[2]);\n                                    if(m3[3] === '%'){\n                                        stop /= 100;\n                                    } else { // px - stupid opera\n                                        stop /= bounds.width;\n                                    }\n                                } else {\n                                    stop = i * step;\n                                }\n                                gradient.colorStops.push({\n                                    color: m3[1],\n                                    stop: stop\n                                });\n                            }\n                        }\n                        break;\n\n                    case '-webkit-gradient':\n\n                        gradient = {\n                            type: m1[2] === 'radial' ? 'circle' : m1[2], // TODO: Add radial gradient support for older mozilla definitions\n                            x0: 0,\n                            y0: 0,\n                            x1: 0,\n                            y1: 0,\n                            colorStops: []\n                        };\n\n                        // get coordinates\n                        m2 = m1[3].match(/(\\d{1,3})%?\\s(\\d{1,3})%?,\\s(\\d{1,3})%?\\s(\\d{1,3})%?/);\n                        if(m2){\n                            gradient.x0 = (m2[1] * bounds.width) / 100;\n                            gradient.y0 = (m2[2] * bounds.height) / 100;\n                            gradient.x1 = (m2[3] * bounds.width) / 100;\n                            gradient.y1 = (m2[4] * bounds.height) / 100;\n                        }\n\n                        // get colors and stops\n                        m2 = m1[4].match(/((?:from|to|color-stop)\\((?:[0-9\\.]+,\\s)?(?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\)\\))+/g);\n                        if(m2){\n                            m2Len = m2.length;\n                            for(i = 0; i < m2Len; i+=1){\n                                m3 = m2[i].match(/(from|to|color-stop)\\(([0-9\\.]+)?(?:,\\s)?((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\))\\)/);\n                                stop = parseFloat(m3[2]);\n                                if(m3[1] === 'from') {\n                                    stop = 0.0;\n                                }\n                                if(m3[1] === 'to') {\n                                    stop = 1.0;\n                                }\n                                gradient.colorStops.push({\n                                    color: m3[3],\n                                    stop: stop\n                                });\n                            }\n                        }\n                        break;\n\n                    case '-moz-linear-gradient':\n\n                        gradient = {\n                            type: 'linear',\n                            x0: 0,\n                            y0: 0,\n                            x1: 0,\n                            y1: 0,\n                            colorStops: []\n                        };\n\n                        // get coordinates\n                        m2 = m1[2].match(/(\\d{1,3})%?\\s(\\d{1,3})%?/);\n\n                        // m2[1] == 0%   -> left\n                        // m2[1] == 50%  -> center\n                        // m2[1] == 100% -> right\n\n                        // m2[2] == 0%   -> top\n                        // m2[2] == 50%  -> center\n                        // m2[2] == 100% -> bottom\n\n                        if(m2){\n                            gradient.x0 = (m2[1] * bounds.width) / 100;\n                            gradient.y0 = (m2[2] * bounds.height) / 100;\n                            gradient.x1 = bounds.width - gradient.x0;\n                            gradient.y1 = bounds.height - gradient.y0;\n                        }\n\n                        // get colors and stops\n                        m2 = m1[3].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\)(?:\\s\\d{1,3}%)?)+/g);\n                        if(m2){\n                            m2Len = m2.length;\n                            step = 1 / Math.max(m2Len - 1, 1);\n                            for(i = 0; i < m2Len; i+=1){\n                                m3 = m2[i].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\))\\s*(\\d{1,3})?(%)?/);\n                                if(m3[2]){\n                                    stop = parseFloat(m3[2]);\n                                    if(m3[3]){ // percentage\n                                        stop /= 100;\n                                    }\n                                } else {\n                                    stop = i * step;\n                                }\n                                gradient.colorStops.push({\n                                    color: m3[1],\n                                    stop: stop\n                                });\n                            }\n                        }\n                        break;\n\n                    case '-webkit-radial-gradient':\n                    case '-moz-radial-gradient':\n                    case '-o-radial-gradient':\n\n                        gradient = {\n                            type: 'circle',\n                            x0: 0,\n                            y0: 0,\n                            x1: bounds.width,\n                            y1: bounds.height,\n                            cx: 0,\n                            cy: 0,\n                            rx: 0,\n                            ry: 0,\n                            colorStops: []\n                        };\n\n                        // center\n                        m2 = m1[2].match(/(\\d{1,3})%?\\s(\\d{1,3})%?/);\n                        if(m2){\n                            gradient.cx = (m2[1] * bounds.width) / 100;\n                            gradient.cy = (m2[2] * bounds.height) / 100;\n                        }\n\n                        // size\n                        m2 = m1[3].match(/\\w+/);\n                        m3 = m1[4].match(/[a-z\\-]*/);\n                        if(m2 && m3){\n                            switch(m3[0]){\n                                case 'farthest-corner':\n                                case 'cover': // is equivalent to farthest-corner\n                                case '': // mozilla removes \"cover\" from definition :(\n                                    tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));\n                                    tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));\n                                    br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));\n                                    bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));\n                                    gradient.rx = gradient.ry = Math.max(tl, tr, br, bl);\n                                    break;\n                                case 'closest-corner':\n                                    tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));\n                                    tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));\n                                    br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));\n                                    bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));\n                                    gradient.rx = gradient.ry = Math.min(tl, tr, br, bl);\n                                    break;\n                                case 'farthest-side':\n                                    if(m2[0] === 'circle'){\n                                        gradient.rx = gradient.ry = Math.max(\n                                            gradient.cx,\n                                            gradient.cy,\n                                            gradient.x1 - gradient.cx,\n                                            gradient.y1 - gradient.cy\n                                        );\n                                    } else { // ellipse\n\n                                        gradient.type = m2[0];\n\n                                        gradient.rx = Math.max(\n                                            gradient.cx,\n                                            gradient.x1 - gradient.cx\n                                        );\n                                        gradient.ry = Math.max(\n                                            gradient.cy,\n                                            gradient.y1 - gradient.cy\n                                        );\n                                    }\n                                    break;\n                                case 'closest-side':\n                                case 'contain': // is equivalent to closest-side\n                                    if(m2[0] === 'circle'){\n                                        gradient.rx = gradient.ry = Math.min(\n                                            gradient.cx,\n                                            gradient.cy,\n                                            gradient.x1 - gradient.cx,\n                                            gradient.y1 - gradient.cy\n                                        );\n                                    } else { // ellipse\n\n                                        gradient.type = m2[0];\n\n                                        gradient.rx = Math.min(\n                                            gradient.cx,\n                                            gradient.x1 - gradient.cx\n                                        );\n                                        gradient.ry = Math.min(\n                                            gradient.cy,\n                                            gradient.y1 - gradient.cy\n                                        );\n                                    }\n                                    break;\n\n                                // TODO: add support for \"30px 40px\" sizes (webkit only)\n                            }\n                        }\n\n                        // color stops\n                        m2 = m1[5].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\)(?:\\s\\d{1,3}(?:%|px))?)+/g);\n                        if(m2){\n                            m2Len = m2.length;\n                            step = 1 / Math.max(m2Len - 1, 1);\n                            for(i = 0; i < m2Len; i+=1){\n                                m3 = m2[i].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\))\\s*(\\d{1,3})?(%|px)?/);\n                                if(m3[2]){\n                                    stop = parseFloat(m3[2]);\n                                    if(m3[3] === '%'){\n                                        stop /= 100;\n                                    } else { // px - stupid opera\n                                        stop /= bounds.width;\n                                    }\n                                } else {\n                                    stop = i * step;\n                                }\n                                gradient.colorStops.push({\n                                    color: m3[1],\n                                    stop: stop\n                                });\n                            }\n                        }\n                        break;\n                }\n            }\n\n            return gradient;\n        };\n\n        function addScrollStops(grad) {\n            return function(colorStop) {\n                try {\n                    grad.addColorStop(colorStop.stop, colorStop.color);\n                }\n                catch(e) {\n                    Util.log(['failed to add color stop: ', e, '; tried to add: ', colorStop]);\n                }\n            };\n        }\n\n        Generate.Gradient = function(src, bounds) {\n            if(bounds.width === 0 || bounds.height === 0) {\n                return;\n            }\n\n            var canvas = document.createElement('canvas'),\n                ctx = canvas.getContext('2d'),\n                gradient, grad;\n\n            canvas.width = bounds.width;\n            canvas.height = bounds.height;\n\n            // TODO: add support for multi defined background gradients\n            gradient = _html2canvas.Generate.parseGradient(src, bounds);\n\n            if(gradient) {\n                switch(gradient.type) {\n                    case 'linear':\n                        grad = ctx.createLinearGradient(gradient.x0, gradient.y0, gradient.x1, gradient.y1);\n                        gradient.colorStops.forEach(addScrollStops(grad));\n                        ctx.fillStyle = grad;\n                        ctx.fillRect(0, 0, bounds.width, bounds.height);\n                        break;\n\n                    case 'circle':\n                        grad = ctx.createRadialGradient(gradient.cx, gradient.cy, 0, gradient.cx, gradient.cy, gradient.rx);\n                        gradient.colorStops.forEach(addScrollStops(grad));\n                        ctx.fillStyle = grad;\n                        ctx.fillRect(0, 0, bounds.width, bounds.height);\n                        break;\n\n                    case 'ellipse':\n                        var canvasRadial = document.createElement('canvas'),\n                            ctxRadial = canvasRadial.getContext('2d'),\n                            ri = Math.max(gradient.rx, gradient.ry),\n                            di = ri * 2;\n\n                        canvasRadial.width = canvasRadial.height = di;\n\n                        grad = ctxRadial.createRadialGradient(gradient.rx, gradient.ry, 0, gradient.rx, gradient.ry, ri);\n                        gradient.colorStops.forEach(addScrollStops(grad));\n\n                        ctxRadial.fillStyle = grad;\n                        ctxRadial.fillRect(0, 0, di, di);\n\n                        ctx.fillStyle = gradient.colorStops[gradient.colorStops.length - 1].color;\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        ctx.drawImage(canvasRadial, gradient.cx - gradient.rx, gradient.cy - gradient.ry, 2 * gradient.rx, 2 * gradient.ry);\n                        break;\n                }\n            }\n\n            return canvas;\n        };\n\n        Generate.ListAlpha = function(number) {\n            var tmp = \"\",\n                modulus;\n\n            do {\n                modulus = number % 26;\n                tmp = String.fromCharCode((modulus) + 64) + tmp;\n                number = number / 26;\n            }while((number*26) > 26);\n\n            return tmp;\n        };\n\n        Generate.ListRoman = function(number) {\n            var romanArray = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"],\n                decimal = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],\n                roman = \"\",\n                v,\n                len = romanArray.length;\n\n            if (number <= 0 || number >= 4000) {\n                return number;\n            }\n\n            for (v=0; v < len; v+=1) {\n                while (number >= decimal[v]) {\n                    number -= decimal[v];\n                    roman += romanArray[v];\n                }\n            }\n\n            return roman;\n        };\n    })();\n    function h2cRenderContext(width, height) {\n        var storage = [];\n        return {\n            storage: storage,\n            width: width,\n            height: height,\n            clip: function() {\n                storage.push({\n                    type: \"function\",\n                    name: \"clip\",\n                    'arguments': arguments\n                });\n            },\n            translate: function() {\n                storage.push({\n                    type: \"function\",\n                    name: \"translate\",\n                    'arguments': arguments\n                });\n            },\n            fill: function() {\n                storage.push({\n                    type: \"function\",\n                    name: \"fill\",\n                    'arguments': arguments\n                });\n            },\n            save: function() {\n                storage.push({\n                    type: \"function\",\n                    name: \"save\",\n                    'arguments': arguments\n                });\n            },\n            restore: function() {\n                storage.push({\n                    type: \"function\",\n                    name: \"restore\",\n                    'arguments': arguments\n                });\n            },\n            fillRect: function () {\n                storage.push({\n                    type: \"function\",\n                    name: \"fillRect\",\n                    'arguments': arguments\n                });\n            },\n            createPattern: function() {\n                storage.push({\n                    type: \"function\",\n                    name: \"createPattern\",\n                    'arguments': arguments\n                });\n            },\n            drawShape: function() {\n\n                var shape = [];\n\n                storage.push({\n                    type: \"function\",\n                    name: \"drawShape\",\n                    'arguments': shape\n                });\n\n                return {\n                    moveTo: function() {\n                        shape.push({\n                            name: \"moveTo\",\n                            'arguments': arguments\n                        });\n                    },\n                    lineTo: function() {\n                        shape.push({\n                            name: \"lineTo\",\n                            'arguments': arguments\n                        });\n                    },\n                    arcTo: function() {\n                        shape.push({\n                            name: \"arcTo\",\n                            'arguments': arguments\n                        });\n                    },\n                    bezierCurveTo: function() {\n                        shape.push({\n                            name: \"bezierCurveTo\",\n                            'arguments': arguments\n                        });\n                    },\n                    quadraticCurveTo: function() {\n                        shape.push({\n                            name: \"quadraticCurveTo\",\n                            'arguments': arguments\n                        });\n                    }\n                };\n\n            },\n            drawImage: function () {\n                storage.push({\n                    type: \"function\",\n                    name: \"drawImage\",\n                    'arguments': arguments\n                });\n            },\n            fillText: function () {\n                storage.push({\n                    type: \"function\",\n                    name: \"fillText\",\n                    'arguments': arguments\n                });\n            },\n            setVariable: function (variable, value) {\n                storage.push({\n                    type: \"variable\",\n                    name: variable,\n                    'arguments': value\n                });\n                return value;\n            }\n        };\n    }\n    _html2canvas.Parse = function (images, options) {\n        window.scroll(0,0);\n\n        var element = (( options.elements === undefined ) ? document.body : options.elements[0]), // select body by default\n            numDraws = 0,\n            doc = element.ownerDocument,\n            Util = _html2canvas.Util,\n            support = Util.Support(options, doc),\n            ignoreElementsRegExp = new RegExp(\"(\" + options.ignoreElements + \")\"),\n            body = doc.body,\n            getCSS = Util.getCSS,\n            pseudoHide = \"___html2canvas___pseudoelement\",\n            hidePseudoElements = doc.createElement('style');\n\n        hidePseudoElements.innerHTML = '.' + pseudoHide + '-before:before { content: \"\" !important; display: none !important; }' +\n            '.' + pseudoHide + '-after:after { content: \"\" !important; display: none !important; }';\n\n        body.appendChild(hidePseudoElements);\n\n        images = images || {};\n\n        function documentWidth () {\n            return Math.max(\n                Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),\n                Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),\n                Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)\n            );\n        }\n\n        function documentHeight () {\n            return Math.max(\n                Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),\n                Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),\n                Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)\n            );\n        }\n\n        function getCSSInt(element, attribute) {\n            var val = parseInt(getCSS(element, attribute), 10);\n            return (isNaN(val)) ? 0 : val; // borders in old IE are throwing 'medium' for demo.html\n        }\n\n        function renderRect (ctx, x, y, w, h, bgcolor) {\n            if (bgcolor !== \"transparent\"){\n                ctx.setVariable(\"fillStyle\", bgcolor);\n                ctx.fillRect(x, y, w, h);\n                numDraws+=1;\n            }\n        }\n\n        function capitalize(m, p1, p2) {\n            if (m.length > 0) {\n                return p1 + p2.toUpperCase();\n            }\n        }\n\n        function textTransform (text, transform) {\n            switch(transform){\n                case \"lowercase\":\n                    return text.toLowerCase();\n                case \"capitalize\":\n                    return text.replace( /(^|\\s|:|-|\\(|\\))([a-z])/g, capitalize);\n                case \"uppercase\":\n                    return text.toUpperCase();\n                default:\n                    return text;\n            }\n        }\n\n        function noLetterSpacing(letter_spacing) {\n            return (/^(normal|none|0px)$/.test(letter_spacing));\n        }\n\n        function drawText(currentText, x, y, ctx){\n            if (currentText !== null && Util.trimText(currentText).length > 0) {\n                ctx.fillText(currentText, x, y);\n                numDraws+=1;\n            }\n        }\n\n        function setTextVariables(ctx, el, text_decoration, color) {\n            var align = false,\n                bold = getCSS(el, \"fontWeight\"),\n                family = getCSS(el, \"fontFamily\"),\n                size = getCSS(el, \"fontSize\"),\n                shadows = Util.parseTextShadows(getCSS(el, \"textShadow\"));\n\n            switch(parseInt(bold, 10)){\n                case 401:\n                    bold = \"bold\";\n                    break;\n                case 400:\n                    bold = \"normal\";\n                    break;\n            }\n\n            ctx.setVariable(\"fillStyle\", color);\n            ctx.setVariable(\"font\", [getCSS(el, \"fontStyle\"), getCSS(el, \"fontVariant\"), bold, size, family].join(\" \"));\n            ctx.setVariable(\"textAlign\", (align) ? \"right\" : \"left\");\n\n            if (shadows.length) {\n                // TODO: support multiple text shadows\n                // apply the first text shadow\n                ctx.setVariable(\"shadowColor\", shadows[0].color);\n                ctx.setVariable(\"shadowOffsetX\", shadows[0].offsetX);\n                ctx.setVariable(\"shadowOffsetY\", shadows[0].offsetY);\n                ctx.setVariable(\"shadowBlur\", shadows[0].blur);\n            }\n\n            if (text_decoration !== \"none\"){\n                return Util.Font(family, size, doc, options);\n            }\n        }\n\n        function renderTextDecoration(ctx, text_decoration, bounds, metrics, color) {\n            switch(text_decoration) {\n                case \"underline\":\n                    // Draws a line at the baseline of the font\n                    // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size\n                    renderRect(ctx, bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, color);\n                    break;\n                case \"overline\":\n                    renderRect(ctx, bounds.left, Math.round(bounds.top), bounds.width, 1, color);\n                    break;\n                case \"line-through\":\n                    // TODO try and find exact position for line-through\n                    renderRect(ctx, bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, color);\n                    break;\n            }\n        }\n\n        function getTextBounds(state, text, textDecoration, isLast, transform) {\n            var bounds;\n            if (support.rangeBounds && !transform) {\n                if (textDecoration !== \"none\" || Util.trimText(text).length !== 0) {\n                    bounds = textRangeBounds(text, state.node, state.textOffset);\n                }\n                state.textOffset += text.length;\n            } else if (state.node && typeof state.node.nodeValue === \"string\" ){\n                var newTextNode = (isLast) ? state.node.splitText(text.length) : null;\n                bounds = textWrapperBounds(state.node, transform);\n                state.node = newTextNode;\n            }\n            return bounds;\n        }\n\n        function textRangeBounds(text, textNode, textOffset) {\n            var range = doc.createRange();\n            range.setStart(textNode, textOffset);\n            range.setEnd(textNode, textOffset + text.length);\n            return range.getBoundingClientRect();\n        }\n\n        function textWrapperBounds(oldTextNode, transform) {\n            var parent = oldTextNode.parentNode,\n                wrapElement = doc.createElement('wrapper'),\n                backupText = oldTextNode.cloneNode(true);\n\n            wrapElement.appendChild(oldTextNode.cloneNode(true));\n            parent.replaceChild(wrapElement, oldTextNode);\n\n            var bounds = transform ? Util.OffsetBounds(wrapElement) : Util.Bounds(wrapElement);\n            parent.replaceChild(backupText, wrapElement);\n            return bounds;\n        }\n\n        function renderText(el, textNode, stack) {\n            var ctx = stack.ctx,\n                color = getCSS(el, \"color\"),\n                textDecoration = getCSS(el, \"textDecoration\"),\n                textAlign = getCSS(el, \"textAlign\"),\n                metrics,\n                textList,\n                state = {\n                    node: textNode,\n                    textOffset: 0\n                };\n\n            if (Util.trimText(textNode.nodeValue).length > 0) {\n                textNode.nodeValue = textTransform(textNode.nodeValue, getCSS(el, \"textTransform\"));\n                textAlign = textAlign.replace([\"-webkit-auto\"],[\"auto\"]);\n\n                textList = (!options.letterRendering && /^(left|right|justify|auto)$/.test(textAlign) && noLetterSpacing(getCSS(el, \"letterSpacing\"))) ?\n                    textNode.nodeValue.split(/(\\b| )/)\n                    : textNode.nodeValue.split(\"\");\n\n                metrics = setTextVariables(ctx, el, textDecoration, color);\n\n                if (options.chinese) {\n                    textList.forEach(function(word, index) {\n                        if (/.*[\\u4E00-\\u9FA5].*$/.test(word)) {\n                            word = word.split(\"\");\n                            word.unshift(index, 1);\n                            textList.splice.apply(textList, word);\n                        }\n                    });\n                }\n\n                textList.forEach(function(text, index) {\n                    var bounds = getTextBounds(state, text, textDecoration, (index < textList.length - 1), stack.transform.matrix);\n                    if (bounds) {\n                        drawText(text, bounds.left, bounds.bottom, ctx);\n                        renderTextDecoration(ctx, textDecoration, bounds, metrics, color);\n                    }\n                });\n            }\n        }\n\n        function listPosition (element, val) {\n            var boundElement = doc.createElement( \"boundelement\" ),\n                originalType,\n                bounds;\n\n            boundElement.style.display = \"inline\";\n\n            originalType = element.style.listStyleType;\n            element.style.listStyleType = \"none\";\n\n            boundElement.appendChild(doc.createTextNode(val));\n\n            element.insertBefore(boundElement, element.firstChild);\n\n            bounds = Util.Bounds(boundElement);\n            element.removeChild(boundElement);\n            element.style.listStyleType = originalType;\n            return bounds;\n        }\n\n        function elementIndex(el) {\n            var i = -1,\n                count = 1,\n                childs = el.parentNode.childNodes;\n\n            if (el.parentNode) {\n                while(childs[++i] !== el) {\n                    if (childs[i].nodeType === 1) {\n                        count++;\n                    }\n                }\n                return count;\n            } else {\n                return -1;\n            }\n        }\n\n        function listItemText(element, type) {\n            var currentIndex = elementIndex(element), text;\n            switch(type){\n                case \"decimal\":\n                    text = currentIndex;\n                    break;\n                case \"decimal-leading-zero\":\n                    text = (currentIndex.toString().length === 1) ? currentIndex = \"0\" + currentIndex.toString() : currentIndex.toString();\n                    break;\n                case \"upper-roman\":\n                    text = _html2canvas.Generate.ListRoman( currentIndex );\n                    break;\n                case \"lower-roman\":\n                    text = _html2canvas.Generate.ListRoman( currentIndex ).toLowerCase();\n                    break;\n                case \"lower-alpha\":\n                    text = _html2canvas.Generate.ListAlpha( currentIndex ).toLowerCase();\n                    break;\n                case \"upper-alpha\":\n                    text = _html2canvas.Generate.ListAlpha( currentIndex );\n                    break;\n            }\n\n            return text + \". \";\n        }\n\n        function renderListItem(element, stack, elBounds) {\n            var x,\n                text,\n                ctx = stack.ctx,\n                type = getCSS(element, \"listStyleType\"),\n                listBounds;\n\n            if (/^(decimal|decimal-leading-zero|upper-alpha|upper-latin|upper-roman|lower-alpha|lower-greek|lower-latin|lower-roman)$/i.test(type)) {\n                text = listItemText(element, type);\n                listBounds = listPosition(element, text);\n                setTextVariables(ctx, element, \"none\", getCSS(element, \"color\"));\n\n                if (getCSS(element, \"listStylePosition\") === \"inside\") {\n                    ctx.setVariable(\"textAlign\", \"left\");\n                    x = elBounds.left;\n                } else {\n                    return;\n                }\n\n                drawText(text, x, listBounds.bottom, ctx);\n            }\n        }\n\n        function loadImage (src){\n            var img = images[src];\n            return (img && img.succeeded === true) ? img.img : false;\n        }\n\n        function clipBounds(src, dst){\n            var x = Math.max(src.left, dst.left),\n                y = Math.max(src.top, dst.top),\n                x2 = Math.min((src.left + src.width), (dst.left + dst.width)),\n                y2 = Math.min((src.top + src.height), (dst.top + dst.height));\n\n            return {\n                left:x,\n                top:y,\n                width:x2-x,\n                height:y2-y\n            };\n        }\n\n        function setZ(element, stack, parentStack){\n            var newContext,\n                isPositioned = stack.cssPosition !== 'static',\n                zIndex = isPositioned ? getCSS(element, 'zIndex') : 'auto',\n                opacity = getCSS(element, 'opacity'),\n                isFloated = getCSS(element, 'cssFloat') !== 'none';\n\n            // https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context\n            // When a new stacking context should be created:\n            // the root element (HTML),\n            // positioned (absolutely or relatively) with a z-index value other than \"auto\",\n            // elements with an opacity value less than 1. (See the specification for opacity),\n            // on mobile WebKit and Chrome 22+, position: fixed always creates a new stacking context, even when z-index is \"auto\" (See this post)\n\n            stack.zIndex = newContext = h2czContext(zIndex);\n            newContext.isPositioned = isPositioned;\n            newContext.isFloated = isFloated;\n            newContext.opacity = opacity;\n            newContext.ownStacking = (zIndex !== 'auto' || opacity < 1);\n\n            if (parentStack) {\n                parentStack.zIndex.children.push(stack);\n            }\n        }\n\n        function renderImage(ctx, element, image, bounds, borders) {\n\n            var paddingLeft = getCSSInt(element, 'paddingLeft'),\n                paddingTop = getCSSInt(element, 'paddingTop'),\n                paddingRight = getCSSInt(element, 'paddingRight'),\n                paddingBottom = getCSSInt(element, 'paddingBottom');\n\n            drawImage(\n                ctx,\n                image,\n                0, //sx\n                0, //sy\n                image.width, //sw\n                image.height, //sh\n                bounds.left + paddingLeft + borders[3].width, //dx\n                bounds.top + paddingTop + borders[0].width, // dy\n                bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight), //dw\n                bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom) //dh\n            );\n        }\n\n        function getBorderData(element) {\n            return [\"Top\", \"Right\", \"Bottom\", \"Left\"].map(function(side) {\n                return {\n                    width: getCSSInt(element, 'border' + side + 'Width'),\n                    color: getCSS(element, 'border' + side + 'Color')\n                };\n            });\n        }\n\n        function getBorderRadiusData(element) {\n            return [\"TopLeft\", \"TopRight\", \"BottomRight\", \"BottomLeft\"].map(function(side) {\n                return getCSS(element, 'border' + side + 'Radius');\n            });\n        }\n\n        var getCurvePoints = (function(kappa) {\n\n            return function(x, y, r1, r2) {\n                var ox = (r1) * kappa, // control point offset horizontal\n                    oy = (r2) * kappa, // control point offset vertical\n                    xm = x + r1, // x-middle\n                    ym = y + r2; // y-middle\n                return {\n                    topLeft: bezierCurve({\n                        x:x,\n                        y:ym\n                    }, {\n                        x:x,\n                        y:ym - oy\n                    }, {\n                        x:xm - ox,\n                        y:y\n                    }, {\n                        x:xm,\n                        y:y\n                    }),\n                    topRight: bezierCurve({\n                        x:x,\n                        y:y\n                    }, {\n                        x:x + ox,\n                        y:y\n                    }, {\n                        x:xm,\n                        y:ym - oy\n                    }, {\n                        x:xm,\n                        y:ym\n                    }),\n                    bottomRight: bezierCurve({\n                        x:xm,\n                        y:y\n                    }, {\n                        x:xm,\n                        y:y + oy\n                    }, {\n                        x:x + ox,\n                        y:ym\n                    }, {\n                        x:x,\n                        y:ym\n                    }),\n                    bottomLeft: bezierCurve({\n                        x:xm,\n                        y:ym\n                    }, {\n                        x:xm - ox,\n                        y:ym\n                    }, {\n                        x:x,\n                        y:y + oy\n                    }, {\n                        x:x,\n                        y:y\n                    })\n                };\n            };\n        })(4 * ((Math.sqrt(2) - 1) / 3));\n\n        function bezierCurve(start, startControl, endControl, end) {\n\n            var lerp = function (a, b, t) {\n                return {\n                    x:a.x + (b.x - a.x) * t,\n                    y:a.y + (b.y - a.y) * t\n                };\n            };\n\n            return {\n                start: start,\n                startControl: startControl,\n                endControl: endControl,\n                end: end,\n                subdivide: function(t) {\n                    var ab = lerp(start, startControl, t),\n                        bc = lerp(startControl, endControl, t),\n                        cd = lerp(endControl, end, t),\n                        abbc = lerp(ab, bc, t),\n                        bccd = lerp(bc, cd, t),\n                        dest = lerp(abbc, bccd, t);\n                    return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];\n                },\n                curveTo: function(borderArgs) {\n                    borderArgs.push([\"bezierCurve\", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);\n                },\n                curveToReversed: function(borderArgs) {\n                    borderArgs.push([\"bezierCurve\", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);\n                }\n            };\n        }\n\n        function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {\n            if (radius1[0] > 0 || radius1[1] > 0) {\n                borderArgs.push([\"line\", corner1[0].start.x, corner1[0].start.y]);\n                corner1[0].curveTo(borderArgs);\n                corner1[1].curveTo(borderArgs);\n            } else {\n                borderArgs.push([\"line\", x, y]);\n            }\n\n            if (radius2[0] > 0 || radius2[1] > 0) {\n                borderArgs.push([\"line\", corner2[0].start.x, corner2[0].start.y]);\n            }\n        }\n\n        function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {\n            var borderArgs = [];\n\n            if (radius1[0] > 0 || radius1[1] > 0) {\n                borderArgs.push([\"line\", outer1[1].start.x, outer1[1].start.y]);\n                outer1[1].curveTo(borderArgs);\n            } else {\n                borderArgs.push([ \"line\", borderData.c1[0], borderData.c1[1]]);\n            }\n\n            if (radius2[0] > 0 || radius2[1] > 0) {\n                borderArgs.push([\"line\", outer2[0].start.x, outer2[0].start.y]);\n                outer2[0].curveTo(borderArgs);\n                borderArgs.push([\"line\", inner2[0].end.x, inner2[0].end.y]);\n                inner2[0].curveToReversed(borderArgs);\n            } else {\n                borderArgs.push([ \"line\", borderData.c2[0], borderData.c2[1]]);\n                borderArgs.push([ \"line\", borderData.c3[0], borderData.c3[1]]);\n            }\n\n            if (radius1[0] > 0 || radius1[1] > 0) {\n                borderArgs.push([\"line\", inner1[1].end.x, inner1[1].end.y]);\n                inner1[1].curveToReversed(borderArgs);\n            } else {\n                borderArgs.push([ \"line\", borderData.c4[0], borderData.c4[1]]);\n            }\n\n            return borderArgs;\n        }\n\n        function calculateCurvePoints(bounds, borderRadius, borders) {\n\n            var x = bounds.left,\n                y = bounds.top,\n                width = bounds.width,\n                height = bounds.height,\n\n                tlh = borderRadius[0][0],\n                tlv = borderRadius[0][1],\n                trh = borderRadius[1][0],\n                trv = borderRadius[1][1],\n                brh = borderRadius[2][0],\n                brv = borderRadius[2][1],\n                blh = borderRadius[3][0],\n                blv = borderRadius[3][1],\n\n                topWidth = width - trh,\n                rightHeight = height - brv,\n                bottomWidth = width - brh,\n                leftHeight = height - blv;\n\n            return {\n                topLeftOuter: getCurvePoints(\n                    x,\n                    y,\n                    tlh,\n                    tlv\n                ).topLeft.subdivide(0.5),\n\n                topLeftInner: getCurvePoints(\n                    x + borders[3].width,\n                    y + borders[0].width,\n                    Math.max(0, tlh - borders[3].width),\n                    Math.max(0, tlv - borders[0].width)\n                ).topLeft.subdivide(0.5),\n\n                topRightOuter: getCurvePoints(\n                    x + topWidth,\n                    y,\n                    trh,\n                    trv\n                ).topRight.subdivide(0.5),\n\n                topRightInner: getCurvePoints(\n                    x + Math.min(topWidth, width + borders[3].width),\n                    y + borders[0].width,\n                    (topWidth > width + borders[3].width) ? 0 :trh - borders[3].width,\n                    trv - borders[0].width\n                ).topRight.subdivide(0.5),\n\n                bottomRightOuter: getCurvePoints(\n                    x + bottomWidth,\n                    y + rightHeight,\n                    brh,\n                    brv\n                ).bottomRight.subdivide(0.5),\n\n                bottomRightInner: getCurvePoints(\n                    x + Math.min(bottomWidth, width + borders[3].width),\n                    y + Math.min(rightHeight, height + borders[0].width),\n                    Math.max(0, brh - borders[1].width),\n                    Math.max(0, brv - borders[2].width)\n                ).bottomRight.subdivide(0.5),\n\n                bottomLeftOuter: getCurvePoints(\n                    x,\n                    y + leftHeight,\n                    blh,\n                    blv\n                ).bottomLeft.subdivide(0.5),\n\n                bottomLeftInner: getCurvePoints(\n                    x + borders[3].width,\n                    y + leftHeight,\n                    Math.max(0, blh - borders[3].width),\n                    Math.max(0, blv - borders[2].width)\n                ).bottomLeft.subdivide(0.5)\n            };\n        }\n\n        function getBorderClip(element, borderPoints, borders, radius, bounds) {\n            var backgroundClip = getCSS(element, 'backgroundClip'),\n                borderArgs = [];\n\n            switch(backgroundClip) {\n                case \"content-box\":\n                case \"padding-box\":\n                    parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);\n                    parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);\n                    parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);\n                    parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);\n                    break;\n\n                default:\n                    parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);\n                    parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);\n                    parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);\n                    parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);\n                    break;\n            }\n\n            return borderArgs;\n        }\n\n        function parseBorders(element, bounds, borders){\n            var x = bounds.left,\n                y = bounds.top,\n                width = bounds.width,\n                height = bounds.height,\n                borderSide,\n                bx,\n                by,\n                bw,\n                bh,\n                borderArgs,\n            // http://www.w3.org/TR/css3-background/#the-border-radius\n                borderRadius = getBorderRadiusData(element),\n                borderPoints = calculateCurvePoints(bounds, borderRadius, borders),\n                borderData = {\n                    clip: getBorderClip(element, borderPoints, borders, borderRadius, bounds),\n                    borders: []\n                };\n\n            for (borderSide = 0; borderSide < 4; borderSide++) {\n\n                if (borders[borderSide].width > 0) {\n                    bx = x;\n                    by = y;\n                    bw = width;\n                    bh = height - (borders[2].width);\n\n                    switch(borderSide) {\n                        case 0:\n                            // top border\n                            bh = borders[0].width;\n\n                            borderArgs = drawSide({\n                                    c1: [bx, by],\n                                    c2: [bx + bw, by],\n                                    c3: [bx + bw - borders[1].width, by + bh],\n                                    c4: [bx + borders[3].width, by + bh]\n                                }, borderRadius[0], borderRadius[1],\n                                borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);\n                            break;\n                        case 1:\n                            // right border\n                            bx = x + width - (borders[1].width);\n                            bw = borders[1].width;\n\n                            borderArgs = drawSide({\n                                    c1: [bx + bw, by],\n                                    c2: [bx + bw, by + bh + borders[2].width],\n                                    c3: [bx, by + bh],\n                                    c4: [bx, by + borders[0].width]\n                                }, borderRadius[1], borderRadius[2],\n                                borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);\n                            break;\n                        case 2:\n                            // bottom border\n                            by = (by + height) - (borders[2].width);\n                            bh = borders[2].width;\n\n                            borderArgs = drawSide({\n                                    c1: [bx + bw, by + bh],\n                                    c2: [bx, by + bh],\n                                    c3: [bx + borders[3].width, by],\n                                    c4: [bx + bw - borders[3].width, by]\n                                }, borderRadius[2], borderRadius[3],\n                                borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);\n                            break;\n                        case 3:\n                            // left border\n                            bw = borders[3].width;\n\n                            borderArgs = drawSide({\n                                    c1: [bx, by + bh + borders[2].width],\n                                    c2: [bx, by],\n                                    c3: [bx + bw, by + borders[0].width],\n                                    c4: [bx + bw, by + bh]\n                                }, borderRadius[3], borderRadius[0],\n                                borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);\n                            break;\n                    }\n\n                    borderData.borders.push({\n                        args: borderArgs,\n                        color: borders[borderSide].color\n                    });\n\n                }\n            }\n\n            return borderData;\n        }\n\n        function createShape(ctx, args) {\n            var shape = ctx.drawShape();\n            args.forEach(function(border, index) {\n                shape[(index === 0) ? \"moveTo\" : border[0] + \"To\" ].apply(null, border.slice(1));\n            });\n            return shape;\n        }\n\n        function renderBorders(ctx, borderArgs, color) {\n            if (color !== \"transparent\") {\n                ctx.setVariable( \"fillStyle\", color);\n                createShape(ctx, borderArgs);\n                ctx.fill();\n                numDraws+=1;\n            }\n        }\n\n        function renderFormValue (el, bounds, stack){\n\n            var valueWrap = doc.createElement('valuewrap'),\n                cssPropertyArray = ['lineHeight','textAlign','fontFamily','color','fontSize','paddingLeft','paddingTop','width','height','border','borderLeftWidth','borderTopWidth'],\n                textValue,\n                textNode;\n\n            cssPropertyArray.forEach(function(property) {\n                try {\n                    valueWrap.style[property] = getCSS(el, property);\n                } catch(e) {\n                    // Older IE has issues with \"border\"\n                    Util.log(\"html2canvas: Parse: Exception caught in renderFormValue: \" + e.message);\n                }\n            });\n\n            valueWrap.style.borderColor = \"black\";\n            valueWrap.style.borderStyle = \"solid\";\n            valueWrap.style.display = \"block\";\n            valueWrap.style.position = \"absolute\";\n\n            if (/^(submit|reset|button|text|password)$/.test(el.type) || el.nodeName === \"SELECT\"){\n                valueWrap.style.lineHeight = getCSS(el, \"height\");\n            }\n\n            valueWrap.style.top = bounds.top + \"px\";\n            valueWrap.style.left = bounds.left + \"px\";\n\n            textValue = (el.nodeName === \"SELECT\") ? (el.options[el.selectedIndex] || 0).text : el.value;\n            if(!textValue) {\n                textValue = el.placeholder;\n            }\n\n            textNode = doc.createTextNode(textValue);\n\n            valueWrap.appendChild(textNode);\n            body.appendChild(valueWrap);\n\n            renderText(el, textNode, stack);\n            body.removeChild(valueWrap);\n        }\n\n        function drawImage (ctx) {\n            ctx.drawImage.apply(ctx, Array.prototype.slice.call(arguments, 1));\n            numDraws+=1;\n        }\n\n        function getPseudoElement(el, which) {\n            var elStyle = window.getComputedStyle(el, which);\n            if(!elStyle || !elStyle.content || elStyle.content === \"none\" || elStyle.content === \"-moz-alt-content\" || elStyle.display === \"none\") {\n                return;\n            }\n            var content = elStyle.content + '',\n                first = content.substr( 0, 1 );\n            //strips quotes\n            if(first === content.substr( content.length - 1 ) && first.match(/'|\"/)) {\n                content = content.substr( 1, content.length - 2 );\n            }\n\n            var isImage = content.substr( 0, 3 ) === 'url',\n                elps = document.createElement( isImage ? 'img' : 'span' );\n\n            elps.className = pseudoHide + \"-before \" + pseudoHide + \"-after\";\n\n            Object.keys(elStyle).filter(indexedProperty).forEach(function(prop) {\n                // Prevent assigning of read only CSS Rules, ex. length, parentRule\n                try {\n                    elps.style[prop] = elStyle[prop];\n                } catch (e) {\n                    Util.log(['Tried to assign readonly property ', prop, 'Error:', e]);\n                }\n            });\n\n            if(isImage) {\n                elps.src = Util.parseBackgroundImage(content)[0].args[0];\n            } else {\n                elps.innerHTML = content;\n            }\n            return elps;\n        }\n\n        function indexedProperty(property) {\n            return (isNaN(window.parseInt(property, 10)));\n        }\n\n        function injectPseudoElements(el, stack) {\n            var before = getPseudoElement(el, ':before'),\n                after = getPseudoElement(el, ':after');\n            if(!before && !after) {\n                return;\n            }\n\n            if(before) {\n                el.className += \" \" + pseudoHide + \"-before\";\n                el.parentNode.insertBefore(before, el);\n                parseElement(before, stack, true);\n                el.parentNode.removeChild(before);\n                el.className = el.className.replace(pseudoHide + \"-before\", \"\").trim();\n            }\n\n            if (after) {\n                el.className += \" \" + pseudoHide + \"-after\";\n                el.appendChild(after);\n                parseElement(after, stack, true);\n                el.removeChild(after);\n                el.className = el.className.replace(pseudoHide + \"-after\", \"\").trim();\n            }\n\n        }\n\n        function renderBackgroundRepeat(ctx, image, backgroundPosition, bounds) {\n            var offsetX = Math.round(bounds.left + backgroundPosition.left),\n                offsetY = Math.round(bounds.top + backgroundPosition.top);\n\n            ctx.createPattern(image);\n            ctx.translate(offsetX, offsetY);\n            ctx.fill();\n            ctx.translate(-offsetX, -offsetY);\n        }\n\n        function backgroundRepeatShape(ctx, image, backgroundPosition, bounds, left, top, width, height) {\n            var args = [];\n            args.push([\"line\", Math.round(left), Math.round(top)]);\n            args.push([\"line\", Math.round(left + width), Math.round(top)]);\n            args.push([\"line\", Math.round(left + width), Math.round(height + top)]);\n            args.push([\"line\", Math.round(left), Math.round(height + top)]);\n            createShape(ctx, args);\n            ctx.save();\n            ctx.clip();\n            renderBackgroundRepeat(ctx, image, backgroundPosition, bounds);\n            ctx.restore();\n        }\n\n        function renderBackgroundColor(ctx, backgroundBounds, bgcolor) {\n            renderRect(\n                ctx,\n                backgroundBounds.left,\n                backgroundBounds.top,\n                backgroundBounds.width,\n                backgroundBounds.height,\n                bgcolor\n            );\n        }\n\n        function renderBackgroundRepeating(el, bounds, ctx, image, imageIndex) {\n            var backgroundSize = Util.BackgroundSize(el, bounds, image, imageIndex),\n                backgroundPosition = Util.BackgroundPosition(el, bounds, image, imageIndex, backgroundSize),\n                backgroundRepeat = getCSS(el, \"backgroundRepeat\").split(\",\").map(Util.trimText);\n\n            image = resizeImage(image, backgroundSize);\n\n            backgroundRepeat = backgroundRepeat[imageIndex] || backgroundRepeat[0];\n\n            switch (backgroundRepeat) {\n                case \"repeat-x\":\n                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds,\n                        bounds.left, bounds.top + backgroundPosition.top, 99999, image.height);\n                    break;\n\n                case \"repeat-y\":\n                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds,\n                        bounds.left + backgroundPosition.left, bounds.top, image.width, 99999);\n                    break;\n\n                case \"no-repeat\":\n                    backgroundRepeatShape(ctx, image, backgroundPosition, bounds,\n                        bounds.left + backgroundPosition.left, bounds.top + backgroundPosition.top, image.width, image.height);\n                    break;\n\n                default:\n                    renderBackgroundRepeat(ctx, image, backgroundPosition, {\n                        top: bounds.top,\n                        left: bounds.left,\n                        width: image.width,\n                        height: image.height\n                    });\n                    break;\n            }\n        }\n\n        function renderBackgroundImage(element, bounds, ctx) {\n            var backgroundImage = getCSS(element, \"backgroundImage\"),\n                backgroundImages = Util.parseBackgroundImage(backgroundImage),\n                image,\n                imageIndex = backgroundImages.length;\n\n            while(imageIndex--) {\n                backgroundImage = backgroundImages[imageIndex];\n\n                if (!backgroundImage.args || backgroundImage.args.length === 0) {\n                    continue;\n                }\n\n                var key = backgroundImage.method === 'url' ?\n                    backgroundImage.args[0] :\n                    backgroundImage.value;\n\n                image = loadImage(key);\n\n                // TODO add support for background-origin\n                if (image) {\n                    renderBackgroundRepeating(element, bounds, ctx, image, imageIndex);\n                } else {\n                    Util.log(\"html2canvas: Error loading background:\", backgroundImage);\n                }\n            }\n        }\n\n        function resizeImage(image, bounds) {\n            if(image.width === bounds.width && image.height === bounds.height) {\n                return image;\n            }\n\n            var ctx, canvas = doc.createElement('canvas');\n            canvas.width = bounds.width;\n            canvas.height = bounds.height;\n            ctx = canvas.getContext(\"2d\");\n            drawImage(ctx, image, 0, 0, image.width, image.height, 0, 0, bounds.width, bounds.height );\n            return canvas;\n        }\n\n        function setOpacity(ctx, element, parentStack) {\n            return ctx.setVariable(\"globalAlpha\", getCSS(element, \"opacity\") * ((parentStack) ? parentStack.opacity : 1));\n        }\n\n        function removePx(str) {\n            return str.replace(\"px\", \"\");\n        }\n\n        var transformRegExp = /(matrix)\\((.+)\\)/;\n\n        function getTransform(element, parentStack) {\n            var transform = getCSS(element, \"transform\") || getCSS(element, \"-webkit-transform\") || getCSS(element, \"-moz-transform\") || getCSS(element, \"-ms-transform\") || getCSS(element, \"-o-transform\");\n            var transformOrigin = getCSS(element, \"transform-origin\") || getCSS(element, \"-webkit-transform-origin\") || getCSS(element, \"-moz-transform-origin\") || getCSS(element, \"-ms-transform-origin\") || getCSS(element, \"-o-transform-origin\") || \"0px 0px\";\n\n            transformOrigin = transformOrigin.split(\" \").map(removePx).map(Util.asFloat);\n\n            var matrix;\n            if (transform && transform !== \"none\") {\n                var match = transform.match(transformRegExp);\n                if (match) {\n                    switch(match[1]) {\n                        case \"matrix\":\n                            matrix = match[2].split(\",\").map(Util.trimText).map(Util.asFloat);\n                            break;\n                    }\n                }\n            }\n\n            return {\n                origin: transformOrigin,\n                matrix: matrix\n            };\n        }\n\n        function createStack(element, parentStack, bounds, transform) {\n            var ctx = h2cRenderContext((!parentStack) ? documentWidth() : bounds.width , (!parentStack) ? documentHeight() : bounds.height),\n                stack = {\n                    ctx: ctx,\n                    opacity: setOpacity(ctx, element, parentStack),\n                    cssPosition: getCSS(element, \"position\"),\n                    borders: getBorderData(element),\n                    transform: transform,\n                    clip: (parentStack && parentStack.clip) ? Util.Extend( {}, parentStack.clip ) : null\n                };\n\n            setZ(element, stack, parentStack);\n\n            // TODO correct overflow for absolute content residing under a static position\n            if (options.useOverflow === true && /(hidden|scroll|auto)/.test(getCSS(element, \"overflow\")) === true && /(BODY)/i.test(element.nodeName) === false){\n                stack.clip = (stack.clip) ? clipBounds(stack.clip, bounds) : bounds;\n            }\n\n            return stack;\n        }\n\n        function getBackgroundBounds(borders, bounds, clip) {\n            var backgroundBounds = {\n                left: bounds.left + borders[3].width,\n                top: bounds.top + borders[0].width,\n                width: bounds.width - (borders[1].width + borders[3].width),\n                height: bounds.height - (borders[0].width + borders[2].width)\n            };\n\n            if (clip) {\n                backgroundBounds = clipBounds(backgroundBounds, clip);\n            }\n\n            return backgroundBounds;\n        }\n\n        function getBounds(element, transform) {\n            var bounds = (transform.matrix) ? Util.OffsetBounds(element) : Util.Bounds(element);\n            transform.origin[0] += bounds.left;\n            transform.origin[1] += bounds.top;\n            return bounds;\n        }\n\n        function renderElement(element, parentStack, pseudoElement, ignoreBackground) {\n            var transform = getTransform(element, parentStack),\n                bounds = getBounds(element, transform),\n                image,\n                stack = createStack(element, parentStack, bounds, transform),\n                borders = stack.borders,\n                ctx = stack.ctx,\n                backgroundBounds = getBackgroundBounds(borders, bounds, stack.clip),\n                borderData = parseBorders(element, bounds, borders),\n                backgroundColor = (ignoreElementsRegExp.test(element.nodeName)) ? \"#efefef\" : getCSS(element, \"backgroundColor\");\n\n\n            createShape(ctx, borderData.clip);\n\n            ctx.save();\n            ctx.clip();\n\n            if (backgroundBounds.height > 0 && backgroundBounds.width > 0 && !ignoreBackground) {\n                renderBackgroundColor(ctx, bounds, backgroundColor);\n                renderBackgroundImage(element, backgroundBounds, ctx);\n            } else if (ignoreBackground) {\n                stack.backgroundColor =  backgroundColor;\n            }\n\n            ctx.restore();\n\n            borderData.borders.forEach(function(border) {\n                renderBorders(ctx, border.args, border.color);\n            });\n\n            if (!pseudoElement) {\n                injectPseudoElements(element, stack);\n            }\n\n            switch(element.nodeName){\n                case \"IMG\":\n                    if ((image = loadImage(element.getAttribute('src')))) {\n                        renderImage(ctx, element, image, bounds, borders);\n                    } else {\n                        Util.log(\"html2canvas: Error loading <img>:\" + element.getAttribute('src'));\n                    }\n                    break;\n                case \"INPUT\":\n                    // TODO add all relevant type's, i.e. HTML5 new stuff\n                    // todo add support for placeholder attribute for browsers which support it\n                    if (/^(text|url|email|submit|button|reset)$/.test(element.type) && (element.value || element.placeholder || \"\").length > 0){\n                        renderFormValue(element, bounds, stack);\n                    }\n                    break;\n                case \"TEXTAREA\":\n                    if ((element.value || element.placeholder || \"\").length > 0){\n                        renderFormValue(element, bounds, stack);\n                    }\n                    break;\n                case \"SELECT\":\n                    if ((element.options||element.placeholder || \"\").length > 0){\n                        renderFormValue(element, bounds, stack);\n                    }\n                    break;\n                case \"LI\":\n                    renderListItem(element, stack, backgroundBounds);\n                    break;\n                case \"CANVAS\":\n                    renderImage(ctx, element, element, bounds, borders);\n                    break;\n            }\n\n            return stack;\n        }\n\n        function isElementVisible(element) {\n            return (getCSS(element, 'display') !== \"none\" && getCSS(element, 'visibility') !== \"hidden\" && !element.hasAttribute(\"data-html2canvas-ignore\"));\n        }\n\n        function parseElement (element, stack, pseudoElement) {\n            if (isElementVisible(element)) {\n                stack = renderElement(element, stack, pseudoElement, false) || stack;\n                if (!ignoreElementsRegExp.test(element.nodeName)) {\n                    parseChildren(element, stack, pseudoElement);\n                }\n            }\n        }\n\n        function parseChildren(element, stack, pseudoElement) {\n            Util.Children(element).forEach(function(node) {\n                if (node.nodeType === node.ELEMENT_NODE) {\n                    parseElement(node, stack, pseudoElement);\n                } else if (node.nodeType === node.TEXT_NODE) {\n                    renderText(element, node, stack);\n                }\n            });\n        }\n\n        function init() {\n            var background = getCSS(document.documentElement, \"backgroundColor\"),\n                transparentBackground = (Util.isTransparent(background) && element === document.body),\n                stack = renderElement(element, null, false, transparentBackground);\n            parseChildren(element, stack);\n\n            if (transparentBackground) {\n                background = stack.backgroundColor;\n            }\n\n            body.removeChild(hidePseudoElements);\n            return {\n                backgroundColor: background,\n                stack: stack\n            };\n        }\n\n        return init();\n    };\n\n    function h2czContext(zindex) {\n        return {\n            zindex: zindex,\n            children: []\n        };\n    }\n\n    _html2canvas.Preload = function( options ) {\n\n        var images = {\n                numLoaded: 0,   // also failed are counted here\n                numFailed: 0,\n                numTotal: 0,\n                cleanupDone: false\n            },\n            pageOrigin,\n            Util = _html2canvas.Util,\n            methods,\n            i,\n            count = 0,\n            element = options.elements[0] || document.body,\n            doc = element.ownerDocument,\n            domImages = element.getElementsByTagName('img'), // Fetch images of the present element only\n            imgLen = domImages.length,\n            link = doc.createElement(\"a\"),\n            supportCORS = (function( img ){\n                return (img.crossOrigin !== undefined);\n            })(new Image()),\n            timeoutTimer;\n\n        link.href = window.location.href;\n        pageOrigin  = link.protocol + link.host;\n\n        function isSameOrigin(url){\n            link.href = url;\n            link.href = link.href; // YES, BELIEVE IT OR NOT, that is required for IE9 - http://jsfiddle.net/niklasvh/2e48b/\n            var origin = link.protocol + link.host;\n            return (origin === pageOrigin);\n        }\n\n        function start(){\n            Util.log(\"html2canvas: start: images: \" + images.numLoaded + \" / \" + images.numTotal + \" (failed: \" + images.numFailed + \")\");\n            if (!images.firstRun && images.numLoaded >= images.numTotal){\n                Util.log(\"Finished loading images: # \" + images.numTotal + \" (failed: \" + images.numFailed + \")\");\n\n                if (typeof options.complete === \"function\"){\n                    options.complete(images);\n                }\n\n            }\n        }\n\n        // TODO modify proxy to serve images with CORS enabled, where available\n        function proxyGetImage(url, img, imageObj){\n            var callback_name,\n                scriptUrl = options.proxy,\n                script;\n\n            link.href = url;\n            url = link.href; // work around for pages with base href=\"\" set - WARNING: this may change the url\n\n            callback_name = 'html2canvas_' + (count++);\n            imageObj.callbackname = callback_name;\n\n            if (scriptUrl.indexOf(\"?\") > -1) {\n                scriptUrl += \"&\";\n            } else {\n                scriptUrl += \"?\";\n            }\n            scriptUrl += 'url=' + encodeURIComponent(url) + '&callback=' + callback_name;\n            script = doc.createElement(\"script\");\n\n            window[callback_name] = function(a){\n                if (a.substring(0,6) === \"error:\"){\n                    imageObj.succeeded = false;\n                    images.numLoaded++;\n                    images.numFailed++;\n                    start();\n                } else {\n                    setImageLoadHandlers(img, imageObj);\n                    img.src = a;\n                }\n                window[callback_name] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)\n                try {\n                    delete window[callback_name];  // for all browser that support this\n                } catch(ex) {}\n                script.parentNode.removeChild(script);\n                script = null;\n                delete imageObj.script;\n                delete imageObj.callbackname;\n            };\n\n            script.setAttribute(\"type\", \"text/javascript\");\n            script.setAttribute(\"src\", scriptUrl);\n            imageObj.script = script;\n            window.document.body.appendChild(script);\n\n        }\n\n        function loadPseudoElement(element, type) {\n            var style = window.getComputedStyle(element, type),\n                content = style.content;\n            if (content.substr(0, 3) === 'url') {\n                methods.loadImage(_html2canvas.Util.parseBackgroundImage(content)[0].args[0]);\n            }\n            loadBackgroundImages(style.backgroundImage, element);\n        }\n\n        function loadPseudoElementImages(element) {\n            loadPseudoElement(element, \":before\");\n            loadPseudoElement(element, \":after\");\n        }\n\n        function loadGradientImage(backgroundImage, bounds) {\n            var img = _html2canvas.Generate.Gradient(backgroundImage, bounds);\n\n            if (img !== undefined){\n                images[backgroundImage] = {\n                    img: img,\n                    succeeded: true\n                };\n                images.numTotal++;\n                images.numLoaded++;\n                start();\n            }\n        }\n\n        function invalidBackgrounds(background_image) {\n            return (background_image && background_image.method && background_image.args && background_image.args.length > 0 );\n        }\n\n        function loadBackgroundImages(background_image, el) {\n            var bounds;\n\n            _html2canvas.Util.parseBackgroundImage(background_image).filter(invalidBackgrounds).forEach(function(background_image) {\n                if (background_image.method === 'url') {\n                    methods.loadImage(background_image.args[0]);\n                } else if(background_image.method.match(/\\-?gradient$/)) {\n                    if(bounds === undefined) {\n                        bounds = _html2canvas.Util.Bounds(el);\n                    }\n                    loadGradientImage(background_image.value, bounds);\n                }\n            });\n        }\n\n        function getImages (el) {\n            var elNodeType = false;\n\n            // Firefox fails with permission denied on pages with iframes\n            try {\n                Util.Children(el).forEach(getImages);\n            }\n            catch( e ) {}\n\n            try {\n                elNodeType = el.nodeType;\n            } catch (ex) {\n                elNodeType = false;\n                Util.log(\"html2canvas: failed to access some element's nodeType - Exception: \" + ex.message);\n            }\n\n            if (elNodeType === 1 || elNodeType === undefined) {\n                loadPseudoElementImages(el);\n                try {\n                    loadBackgroundImages(Util.getCSS(el, 'backgroundImage'), el);\n                } catch(e) {\n                    Util.log(\"html2canvas: failed to get background-image - Exception: \" + e.message);\n                }\n                loadBackgroundImages(el);\n            }\n        }\n\n        function setImageLoadHandlers(img, imageObj) {\n            img.onload = function() {\n                if ( imageObj.timer !== undefined ) {\n                    // CORS succeeded\n                    window.clearTimeout( imageObj.timer );\n                }\n\n                images.numLoaded++;\n                imageObj.succeeded = true;\n                img.onerror = img.onload = null;\n                start();\n            };\n            img.onerror = function() {\n                if (img.crossOrigin === \"anonymous\") {\n                    // CORS failed\n                    window.clearTimeout( imageObj.timer );\n\n                    // let's try with proxy instead\n                    if ( options.proxy ) {\n                        var src = img.src;\n                        img = new Image();\n                        imageObj.img = img;\n                        img.src = src;\n\n                        proxyGetImage( img.src, img, imageObj );\n                        return;\n                    }\n                }\n\n                images.numLoaded++;\n                images.numFailed++;\n                imageObj.succeeded = false;\n                img.onerror = img.onload = null;\n                start();\n            };\n        }\n\n        methods = {\n            loadImage: function( src ) {\n                var img, imageObj;\n                if ( src && images[src] === undefined ) {\n                    img = new Image();\n                    if ( src.match(/data:image\\/.*;base64,/i) ) {\n                        img.src = src.replace(/url\\(['\"]{0,}|['\"]{0,}\\)$/ig, '');\n                        imageObj = images[src] = {\n                            img: img\n                        };\n                        images.numTotal++;\n                        setImageLoadHandlers(img, imageObj);\n                    } else if ( isSameOrigin( src ) || options.allowTaint ===  true ) {\n                        imageObj = images[src] = {\n                            img: img\n                        };\n                        images.numTotal++;\n                        setImageLoadHandlers(img, imageObj);\n                        img.src = src;\n                    } else if ( supportCORS && !options.allowTaint && options.useCORS ) {\n                        // attempt to load with CORS\n\n                        img.crossOrigin = \"anonymous\";\n                        imageObj = images[src] = {\n                            img: img\n                        };\n                        images.numTotal++;\n                        setImageLoadHandlers(img, imageObj);\n                        img.src = src;\n                    } else if ( options.proxy ) {\n                        imageObj = images[src] = {\n                            img: img\n                        };\n                        images.numTotal++;\n                        proxyGetImage( src, img, imageObj );\n                    }\n                }\n\n            },\n            cleanupDOM: function(cause) {\n                var img, src;\n                if (!images.cleanupDone) {\n                    if (cause && typeof cause === \"string\") {\n                        Util.log(\"html2canvas: Cleanup because: \" + cause);\n                    } else {\n                        Util.log(\"html2canvas: Cleanup after timeout: \" + options.timeout + \" ms.\");\n                    }\n\n                    for (src in images) {\n                        if (images.hasOwnProperty(src)) {\n                            img = images[src];\n                            if (typeof img === \"object\" && img.callbackname && img.succeeded === undefined) {\n                                // cancel proxy image request\n                                window[img.callbackname] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)\n                                try {\n                                    delete window[img.callbackname];  // for all browser that support this\n                                } catch(ex) {}\n                                if (img.script && img.script.parentNode) {\n                                    img.script.setAttribute(\"src\", \"about:blank\");  // try to cancel running request\n                                    img.script.parentNode.removeChild(img.script);\n                                }\n                                images.numLoaded++;\n                                images.numFailed++;\n                                Util.log(\"html2canvas: Cleaned up failed img: '\" + src + \"' Steps: \" + images.numLoaded + \" / \" + images.numTotal);\n                            }\n                        }\n                    }\n\n                    // cancel any pending requests\n                    if(window.stop !== undefined) {\n                        window.stop();\n                    } else if(document.execCommand !== undefined) {\n                        document.execCommand(\"Stop\", false);\n                    }\n                    if (document.close !== undefined) {\n                        document.close();\n                    }\n                    images.cleanupDone = true;\n                    if (!(cause && typeof cause === \"string\")) {\n                        start();\n                    }\n                }\n            },\n\n            renderingDone: function() {\n                if (timeoutTimer) {\n                    window.clearTimeout(timeoutTimer);\n                }\n            }\n        };\n\n        if (options.timeout > 0) {\n            timeoutTimer = window.setTimeout(methods.cleanupDOM, options.timeout);\n        }\n\n        Util.log('html2canvas: Preload starts: finding background-images');\n        images.firstRun = true;\n\n        getImages(element);\n\n        Util.log('html2canvas: Preload: Finding images');\n        // load <img> images\n        for (i = 0; i < imgLen; i+=1){\n            methods.loadImage( domImages[i].getAttribute( \"src\" ) );\n        }\n\n        images.firstRun = false;\n        Util.log('html2canvas: Preload: Done.');\n        if (images.numTotal === images.numLoaded) {\n            start();\n        }\n\n        return methods;\n    };\n\n    _html2canvas.Renderer = function(parseQueue, options){\n\n        // http://www.w3.org/TR/CSS21/zindex.html\n        function createRenderQueue(parseQueue) {\n            var queue = [],\n                rootContext;\n\n            rootContext = (function buildStackingContext(rootNode) {\n                var rootContext = {};\n                function insert(context, node, specialParent) {\n                    var zi = (node.zIndex.zindex === 'auto') ? 0 : Number(node.zIndex.zindex),\n                        contextForChildren = context, // the stacking context for children\n                        isPositioned = node.zIndex.isPositioned,\n                        isFloated = node.zIndex.isFloated,\n                        stub = {node: node},\n                        childrenDest = specialParent; // where children without z-index should be pushed into\n\n                    if (node.zIndex.ownStacking) {\n                        // '!' comes before numbers in sorted array\n                        contextForChildren = stub.context = { '!': [{node:node, children: []}]};\n                        childrenDest = undefined;\n                    } else if (isPositioned || isFloated) {\n                        childrenDest = stub.children = [];\n                    }\n\n                    if (zi === 0 && specialParent) {\n                        specialParent.push(stub);\n                    } else {\n                        if (!context[zi]) { context[zi] = []; }\n                        context[zi].push(stub);\n                    }\n\n                    node.zIndex.children.forEach(function(childNode) {\n                        insert(contextForChildren, childNode, childrenDest);\n                    });\n                }\n                insert(rootContext, rootNode);\n                return rootContext;\n            })(parseQueue);\n\n            function sortZ(context) {\n                Object.keys(context).sort().forEach(function(zi) {\n                    var nonPositioned = [],\n                        floated = [],\n                        positioned = [],\n                        list = [];\n\n                    // positioned after static\n                    context[zi].forEach(function(v) {\n                        if (v.node.zIndex.isPositioned || v.node.zIndex.opacity < 1) {\n                            // http://www.w3.org/TR/css3-color/#transparency\n                            // non-positioned element with opactiy < 1 should be stacked as if it were a positioned element with z-index: 0 and opacity: 1.\n                            positioned.push(v);\n                        } else if (v.node.zIndex.isFloated) {\n                            floated.push(v);\n                        } else {\n                            nonPositioned.push(v);\n                        }\n                    });\n\n                    (function walk(arr) {\n                        arr.forEach(function(v) {\n                            list.push(v);\n                            if (v.children) { walk(v.children); }\n                        });\n                    })(nonPositioned.concat(floated, positioned));\n\n                    list.forEach(function(v) {\n                        if (v.context) {\n                            sortZ(v.context);\n                        } else {\n                            queue.push(v.node);\n                        }\n                    });\n                });\n            }\n\n            sortZ(rootContext);\n\n            return queue;\n        }\n\n        function getRenderer(rendererName) {\n            var renderer;\n\n            if (typeof options.renderer === \"string\" && _html2canvas.Renderer[rendererName] !== undefined) {\n                renderer = _html2canvas.Renderer[rendererName](options);\n            } else if (typeof rendererName === \"function\") {\n                renderer = rendererName(options);\n            } else {\n                throw new Error(\"Unknown renderer\");\n            }\n\n            if ( typeof renderer !== \"function\" ) {\n                throw new Error(\"Invalid renderer defined\");\n            }\n            return renderer;\n        }\n\n        return getRenderer(options.renderer)(parseQueue, options, document, createRenderQueue(parseQueue.stack), _html2canvas);\n    };\n\n    _html2canvas.Util.Support = function (options, doc) {\n\n        function supportSVGRendering() {\n            var img = new Image(),\n                canvas = doc.createElement(\"canvas\"),\n                ctx = (canvas.getContext === undefined) ? false : canvas.getContext(\"2d\");\n            if (ctx === false) {\n                return false;\n            }\n            canvas.width = canvas.height = 10;\n            img.src = [\n                \"data:image/svg+xml,\",\n                \"<svg xmlns='http://www.w3.org/2000/svg' width='10' height='10'>\",\n                \"<foreignObject width='10' height='10'>\",\n                \"<div xmlns='http://www.w3.org/1999/xhtml' style='width:10;height:10;'>\",\n                \"sup\",\n                \"</div>\",\n                \"</foreignObject>\",\n                \"</svg>\"\n            ].join(\"\");\n            try {\n                ctx.drawImage(img, 0, 0);\n                canvas.toDataURL();\n            } catch(e) {\n                return false;\n            }\n            _html2canvas.Util.log('html2canvas: Parse: SVG powered rendering available');\n            return true;\n        }\n\n        // Test whether we can use ranges to measure bounding boxes\n        // Opera doesn't provide valid bounds.height/bottom even though it supports the method.\n\n        function supportRangeBounds() {\n            var r, testElement, rangeBounds, rangeHeight, support = false;\n\n            if (doc.createRange) {\n                r = doc.createRange();\n                if (r.getBoundingClientRect) {\n                    testElement = doc.createElement('boundtest');\n                    testElement.style.height = \"123px\";\n                    testElement.style.display = \"block\";\n                    doc.body.appendChild(testElement);\n\n                    r.selectNode(testElement);\n                    rangeBounds = r.getBoundingClientRect();\n                    rangeHeight = rangeBounds.height;\n\n                    if (rangeHeight === 123) {\n                        support = true;\n                    }\n                    doc.body.removeChild(testElement);\n                }\n            }\n\n            return support;\n        }\n\n        return {\n            rangeBounds: supportRangeBounds(),\n            svgRendering: options.svgRendering && supportSVGRendering()\n        };\n    };\n    window.html2canvas = function(elements, opts) {\n        elements = (elements.length) ? elements : [elements];\n        var queue,\n            canvas,\n            options = {\n                // general\n                logging: false,\n                elements: elements,\n                background: \"#fff\",\n\n                // preload options\n                proxy: null,\n                timeout: 0,    // no timeout\n                useCORS: false, // try to load images as CORS (where available), before falling back to proxy\n                allowTaint: false, // whether to allow images to taint the canvas, won't need proxy if set to true\n\n                // parse options\n                svgRendering: false, // use svg powered rendering where available (FF11+)\n                ignoreElements: \"IFRAME|OBJECT|PARAM\",\n                useOverflow: true,\n                letterRendering: false,\n                chinese: false,\n\n                // render options\n\n                width: null,\n                height: null,\n                taintTest: true, // do a taint test with all images before applying to canvas\n                renderer: \"Canvas\",\n                imagesDir: \"\" // base URL for images used here\n            };\n\n        options = _html2canvas.Util.Extend(opts, options);\n\n        _html2canvas.logging = options.logging;\n        options.complete = function( images ) {\n\n            if (typeof options.onpreloaded === \"function\") {\n                if ( options.onpreloaded( images ) === false ) {\n                    return;\n                }\n            }\n            queue = _html2canvas.Parse( images, options );\n\n            if (typeof options.onparsed === \"function\") {\n                if ( options.onparsed( queue ) === false ) {\n                    return;\n                }\n            }\n\n            canvas = _html2canvas.Renderer( queue, options );\n\n            if (typeof options.onrendered === \"function\") {\n                options.onrendered( canvas );\n            }\n\n\n        };\n\n        // for pages without images, we still want this to be async, i.e. return methods before executing\n        window.setTimeout( function(){\n            _html2canvas.Preload( options );\n        }, 0 );\n\n        return {\n            render: function( queue, opts ) {\n                return _html2canvas.Renderer( queue, _html2canvas.Util.Extend(opts, options) );\n            },\n            parse: function( images, opts ) {\n                return _html2canvas.Parse( images, _html2canvas.Util.Extend(opts, options) );\n            },\n            preload: function( opts ) {\n                return _html2canvas.Preload( _html2canvas.Util.Extend(opts, options) );\n            },\n            log: _html2canvas.Util.log\n        };\n    };\n\n    window.html2canvas.log = _html2canvas.Util.log; // for renderers\n    window.html2canvas.Renderer = {\n        Canvas: undefined // We are assuming this will be used\n    };\n    _html2canvas.Renderer.Canvas = function(options) {\n        options = options || {};\n\n        var doc = document,\n            safeImages = [],\n            testCanvas = document.createElement(\"canvas\"),\n            testctx = testCanvas.getContext(\"2d\"),\n            Util = _html2canvas.Util,\n            canvas = options.canvas || doc.createElement('canvas');\n\n        function createShape(ctx, args) {\n            ctx.beginPath();\n            args.forEach(function(arg) {\n                ctx[arg.name].apply(ctx, arg['arguments']);\n            });\n            ctx.closePath();\n        }\n\n        function safeImage(item) {\n            if (safeImages.indexOf(item['arguments'][0].src ) === -1) {\n                testctx.drawImage(item['arguments'][0], 0, 0);\n                try {\n                    testctx.getImageData(0, 0, 1, 1);\n                } catch(e) {\n                    testCanvas = doc.createElement(\"canvas\");\n                    testctx = testCanvas.getContext(\"2d\");\n                    return false;\n                }\n                safeImages.push(item['arguments'][0].src);\n            }\n            return true;\n        }\n\n        function renderItem(ctx, item) {\n            switch(item.type){\n                case \"variable\":\n                    ctx[item.name] = item['arguments'];\n                    break;\n                case \"function\":\n                    switch(item.name) {\n                        case \"createPattern\":\n                            if (item['arguments'][0].width > 0 && item['arguments'][0].height > 0) {\n                                try {\n                                    ctx.fillStyle = ctx.createPattern(item['arguments'][0], \"repeat\");\n                                }\n                                catch(e) {\n                                    Util.log(\"html2canvas: Renderer: Error creating pattern\", e.message);\n                                }\n                            }\n                            break;\n                        case \"drawShape\":\n                            createShape(ctx, item['arguments']);\n                            break;\n                        case \"drawImage\":\n                            if (item['arguments'][8] > 0 && item['arguments'][7] > 0) {\n                                if (!options.taintTest || (options.taintTest && safeImage(item))) {\n                                    ctx.drawImage.apply( ctx, item['arguments'] );\n                                }\n                            }\n                            break;\n                        default:\n                            ctx[item.name].apply(ctx, item['arguments']);\n                    }\n                    break;\n            }\n        }\n\n        return function(parsedData, options, document, queue, _html2canvas) {\n            var ctx = canvas.getContext(\"2d\"),\n                newCanvas,\n                bounds,\n                fstyle,\n                zStack = parsedData.stack;\n\n            canvas.width = canvas.style.width =  options.width || zStack.ctx.width;\n            canvas.height = canvas.style.height = options.height || zStack.ctx.height;\n\n            fstyle = ctx.fillStyle;\n            ctx.fillStyle = (Util.isTransparent(zStack.backgroundColor) && options.background !== undefined) ? options.background : parsedData.backgroundColor;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = fstyle;\n\n            queue.forEach(function(storageContext) {\n                // set common settings for canvas\n                ctx.textBaseline = \"bottom\";\n                ctx.save();\n\n                if (storageContext.transform.matrix) {\n                    ctx.translate(storageContext.transform.origin[0], storageContext.transform.origin[1]);\n                    ctx.transform.apply(ctx, storageContext.transform.matrix);\n                    ctx.translate(-storageContext.transform.origin[0], -storageContext.transform.origin[1]);\n                }\n\n                if (storageContext.clip){\n                    ctx.beginPath();\n                    ctx.rect(storageContext.clip.left, storageContext.clip.top, storageContext.clip.width, storageContext.clip.height);\n                    ctx.clip();\n                }\n\n                if (storageContext.ctx.storage) {\n                    storageContext.ctx.storage.forEach(function(item) {\n                        renderItem(ctx, item);\n                    });\n                }\n\n                ctx.restore();\n            });\n\n            Util.log(\"html2canvas: Renderer: Canvas renderer done - returning canvas obj\");\n\n            if (options.elements.length === 1) {\n                if (typeof options.elements[0] === \"object\" && options.elements[0].nodeName !== \"BODY\") {\n                    // crop image to the bounds of selected (single) element\n                    bounds = _html2canvas.Util.Bounds(options.elements[0]);\n                    newCanvas = document.createElement('canvas');\n                    newCanvas.width = Math.ceil(bounds.width);\n                    newCanvas.height = Math.ceil(bounds.height);\n                    ctx = newCanvas.getContext(\"2d\");\n\n                    ctx.drawImage(canvas, bounds.left, bounds.top, bounds.width, bounds.height, 0, 0, bounds.width, bounds.height);\n                    canvas = null;\n                    return newCanvas;\n                }\n            }\n\n            return canvas;\n        };\n    };\n})(window,document);\n\n//# sourceURL=webpack:///./external/html2canvas/html2canvas.js?");

/***/ }),

/***/ 7:
/*!***************************************************!*\
  !*** multi ./external/html2canvas/html2canvas.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./external/html2canvas/html2canvas.js */\"./external/html2canvas/html2canvas.js\");\n\n\n//# sourceURL=webpack:///multi_./external/html2canvas/html2canvas.js?");

/***/ })

/******/ });